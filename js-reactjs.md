- A [higher-order component](https://reactjs.org/docs/higher-order-components.html) is a component that takes in a component (instead of props), and returns another component. You can compose new components that way, and somehow, that's better than changing the existing one.
- Custom hooks exist because you can (or, "should") only access application state inside a hook. [Hooks must be at the top of a component, outside of any loops and conditions, and before any early returns](https://reactjs.org/docs/hooks-rules.html#only-call-hooks-at-the-top-level). If you need to conditionally do something, have your hook expose a function that does it conditionally.
- [Regular HTML elements are also React components in JSX](https://reactjs.org/docs/jsx-in-depth.html#user-defined-components-must-be-capitalized); although user-defined components need to start with `UpperCase` and be in scope at time of use, lower-case tags are built-in components that don't need to be in scope. That's also why you still need to write `className` for a `<div>`.
- There's "React Native" for those who regret writing react apps in Cordova, and then there's ["React Native Web"](https://github.com/necolas/react-native-web), for those who regret writing react apps in Cordova, switch to react native, and then regret not being able to run it in a browser. JavaScript is a Mobius strip for ideas.
- [React man](https://youtu.be/mVVNJKv9esE?t=20m54s) admits that it is not their proudest moment to place HTML in JavaScript, but a _concession_ because templates, as a form of data, [although fast] can no longer meet the flexibility needs of code. Turning data into code is a form of abstraction, which prevents optimisation. Man also noted that Ember limits itself to data templates, which are indeed optimisable and are therefore faster.
- In a default `create-react-app` project (or any webpack project, right?), [you literally `import 'a_css_file.css';` in your `index.js` file](https://github.com/reactstrap/reactstrap) to have it bundled, and it is presumed that webpack knows where `node_modules` is.
- React is [the most flexible](https://medium.com/@TechMagic/reactjs-vs-angular5-vs-vue-js-what-to-choose-in-2018-b91e028fa91d), and therefore, the easiest to get wrong, among Angular2+, React, and Vue.
- Events like `onClick` accept handlers whose `this` is the class, so either of these will work: `onClick={this.classMethod.bind(this)}` (where `classMethod() {...}`), or `onClick={this.instanceMethod} (where`instanceMethod = () {...}`).
- In a `.jsx` file, any method can return JSX.
- Component tag names need to start with a capital letter.
- [MobX 5.x](https://github.com/mobxjs/mobx#browser-support) dropped support for any browser that doesn't have [ES6 proxies](https://caniuse.com/#search=proxy).
- In the past, every component has at most one root element in the JSX. As of 2018---I think whenever [React Fiber](https://reactjs.org/blog/2017/09/26/react-v16.0.html) came out---[you can wrap your stuff with `<React.Fragment> ... </React.Fragment>`](https://www.youtube.com/watch?v=oZbTqEmQpDo), which is basically a no-root-element placeholder, or, if you use Babel 7 and above, you can get a react plugin to use the shorthand syntax `<> ... </>`, which does the exact same thing.
- Events are not bound to an instance of the class, so if an event (say `onClick`) handler has `onClick={this.method}`, the `method` inside your component must be `method = () => { ... }` rather than the usual `method() { ... }`. You can alternatively [have `this.handleChange = this.handleChange.bind(this)` in the constructor for every single event](https://www.valentinog.com/blog/babel/).
- [First `state`... then `props`... now `context`...](https://www.youtube.com/watch?v=XLJN4JfniH4) `React.createContext` is a semi-global object provided by a "<xyz.Provider> ... </xyz.Provider>" that is also a subclass of a `Component`. You then wrap your anything (including your root app component) with that `<.Provider>`, and all children can access that same `context` (an anonymous function) in anything you wrap inside `<.Context.Consumer>`. More caveats in the video.
- ["Props" are things passed to a component from the outside](https://user3141592.medium.com/react-gotchas-and-best-practices-2d47fd67dd22)... "state" is generated by the component itself. Now, if you pass this state into a child component, it becomes that child component's props.
- React "Fiber" (16 and up) allows animations to [not stop](https://build-mbfootjxoo.now.sh/) while other elements are rendering.
- [Input elements cannot update react's state unless you give them an `onChange`](https://reactjs.org/docs/forms.html#why-textarea-value). If you really just want to be able to type in a box and not care about the state, you can tell react to shut the fuck up with `onChange={this.noop}`.
- You are not supposed to put any logic inside react components (at least where it can be avoided).
- AirBnB had lots of [good times, and issues](https://medium.com/airbnb-engineering/react-native-at-airbnb-the-technology-dafd0b43838) with React Native. For them (and probably a product their size), they say it was not worth it, but 80% of their engineers had a positive experience (apart from being paid to redo everything).
- JS is so bad at working with CSS that, in 2021, [developers are encouraged to put CSS in JS](https://rencybeth.medium.com/top-8-reactjs-best-practices-to-follow-in-the-year-2021-4abd41618ea4) and have the compiler manage styled components.
- "With hooks, we separate code not based on the lifecycle method name, but based on what the code is doing." - Dan, on [hooks](https://www.youtube.com/watch?v=dpw9EHDh2bM&t=2657s)
- If any of your components [shares state with other non-child components, saves or loads state, or uses the network](https://medium.com/javascript-scene/do-react-hooks-replace-redux-210bab340672), redux is still used in place of hooks. In other words, `useState` and friends are only responsible for component state, not the application state.
- [Mixins are bad](https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html). Use [hooks](https://beta.reactjs.org/) instead.
- Hooks look like `useState`, `useContext`, and `useEffect`. [The `use` prefix is required](https://beta.reactjs.org/learn/state-a-components-memory#meet-your-first-hook), because the compiler looks for those.
- Hooks must be at the top of a function.
- If you choose to write class-based components, you need to unsubscribe event handlers in `componentDidUnmount`.
- `componentDidMount` vs `componentDidUpdate`: mounting happens when the component's element is inserted into the DOM. Updates happen, and that's when the second event fires.
- Every method in a class component needs to be manually bound in the constructor, i.e. `this.someEvent = this.someEvent.bind(this);`... for all of them.
- [`useEffect`](https://reactjs.org/docs/hooks-reference.html#useeffect) allows a component to do something whenever it renders. It can be used more than once. It can specify a cleanup phase, and if it does, return a cleanup function in the effect function.
- [`useEffect` takes in a second argument](https://dmitripavlutin.com/react-useeffect-explanation/), `useEffect(callback, dependencies)`, which conditionally calls `callback` only if `dependencies` have changed. [Those arguments are compared with `Object.is`](https://labs.factorialhr.com/posts/hooks-considered-harmful): we know for a fact that `useEffect(..., [a])` will run as many times as there are unique `a`s.
- The `setState` function in `useState` can also [accept a function that takes in the previous state](https://medium.com/@wisecobbler/using-a-function-in-setstate-instead-of-an-object-1f5cfd6e55d1) (i.e. `setState((prevState) => ...)`), which simplifies the process if you require the previous state *at the time setState is called*, which can change `state` differently if too many async events happen.
- [`setState` is asynchronous](https://stackoverflow.com/questions/36085726/why-is-setstate-in-reactjs-async-instead-of-sync) ðŸ¤¨ operations are batched for performance reasons. Don't expect changes right after you call `setState`. If you need to do something only after the state is set, use a callback function, i.e. `this.setState(..., () => console.log(this.state))`.
- `<!-- HTML comments in JSX -->` [will not work](https://www.geeksforgeeks.org/how-to-write-comments-in-reactjs/). Use `{ /* JS comments and blocks */ }` instead.
- [If you don't want to `this.method = this.method.bind(this)` all the time, try `method = () => {...}`](https://user3141592.medium.com/react-gotchas-and-best-practices-2d47fd67dd22), because arrow functions inside a class don't need to be manually bound to have the correct context. Don't use anonymous functions (i.e. `onClick={ () => this.method() }`), because it has a performance penalty.
- A [pure component](https://blog.logrocket.com/react-pure-components-functional/) is one that is *stateless*; it does not have a state. It is great because it is as easy to debug as a pure function, and you know how awesome pure functions are.
- If you don't need `props` to initialise a component, you can simply initialise it anywhere in the class, without doing so in `constructor(props) {...}`.
- Make sure you call `super(props)` in your constructor :)
- Not sure what `PropTypes` is, but [it's been removed now!](https://jscomplete.com/learn/react-beyond-basics/react-cfp) No need to worry about it.
- `<Greeting counter="7" />` passes the *string* `"7"` to the component. To pass the number `7`, do `<Greeting counter={7} />`.
- The orthodox way to conditionally show a component is [`{condition && <Component />}`](https://reactjs.org/docs/conditional-rendering.html).
- `useLayoutEffect` is the same as `useEffect`, except it fires synchronously (once?) after DOM mutations. ["(for migration code from class-based components to function-based) ... we recommend starting with `useEffect` first and only trying `useLayoutEffect` if that causes a problem."](https://reactjs.org/docs/hooks-reference.html#uselayouteffect)
- [Every component tag can be self-closing](https://react-cn.github.io/react/tips/self-closing-tag.html).
- If you write `return (<foo />)` in a single line, the `()` will be removed by the linter. [Parentheses are necessary only when the JSX is multi-line](https://javascript.plainenglish.io/curly-braces-versus-parenthesis-in-reactjs-4d3ffd33128f).
- [Error boundaries](https://reactjs.org/docs/error-boundaries.html#introducing-error-boundaries) are like try/catch blocks for components: `<ErrorBoundary> <MyWidget /> </ErrorBoundary>` will trigger the `ErrorBoundary` component's `componentDidCatch` method, which functional components do not have.
- [`<React.Suspense fallback={ <...> }>`](https://reactjs.org/docs/react-api.html#reactsuspense) waits for the inner components to load by first loading that `<...>`. "The best practice is to place `<Suspense>` where you want to see a loading indicator, but to use `lazy()` wherever you want to do code splitting."
- It is possible to write react components that don't attach nodes to the inside of its parent node, using [portals](https://reactjs.org/docs/portals.html). With `ReactDOM.createPortal(el, container)`, you can put your element wherever you want.
- You can `<Component key={...}>`, but `key` is never passed into the component. Therefore, [you can never have a prop called `key`](https://reactjs.org/warnings/special-props.html) (or `ref`, for that matter).
- [Events like `onClick` only work on built-in components](https://stackoverflow.com/a/28272148). If you `<CustomComponent onClick={foo}>`, that just passes the event to the component as a prop, which doesn't do anything until that `<CustomComponent>` assigns the handler to a built-in component, like `<div onClick={onClick}>`.
- [`useNavigate()` navigates to internal routes exclusively.](https://stackoverflow.com/questions/71606230/usenavigate-navigate-to-external-link)
- [`props` are immutable](https://reactjs.org/blog/2015/02/24/streamlining-react-elements.html), and should be deep-immutable where you can make it. [Data flow in React is unidirectional](https://www.educative.io/edpresso/what-is-unidirectional-data-flow-in-react) (parent -> child). If you mutate state instead of using the setter from `useState`, any components using that data won't rerender.
